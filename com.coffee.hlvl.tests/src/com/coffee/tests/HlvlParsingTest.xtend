/*
 * generated by Xtext 2.12.0
 */
package com.coffee.tests

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith
import com.coffee.hlvl.Model
import com.coffee.hlvl.HlvlPackage


/**
 * Class to test the correct parsing of HLVL
 * @author Angela Villota
 * @version HLVL V4
 * November 2018
 * 
 */
@RunWith(XtextRunner)
@InjectWith(HlvlInjectorProvider)
class HlvlParsingTest {
	@Inject
	ParseHelper<Model> parseHelper
	@Inject extension ParseHelper // gracias a esta linea se puede hacer el llamado .parse
	
/*********************************************************************************************************
 * Methods to test the parser
 * 
 */
 /**
 * Method to test the interpretation of an empty program
 */
	@Test
	def void emptyModel() {
		// model is a program in PLEC
		val model = 
		'''
		model empty
		elements:
		relations:
		'''
		//empty is an empty model
		val empty = parseHelper.parse(model)
		Assert.assertNotNull(empty)
		Assert.assertTrue(empty.eResource.errors.isEmpty)
	}
	
	@Test
	def void elements() {
		// model is a program in PLEC
		val program = 
		'''
		model eShop
		  elements:
		  boolean connectionType
		  symbolic customerType variants: ['sporadic' , 'regular'] comment: {"What is the customer type?"}
		  //instantiable [1,5] boolean  appServer
		  //instantiable [2,10] boolean serverMachines
		  att integer confidentiality variants: 1..5
		  att integer confidentialityBounded is 2
		  integer notAtt variants:[2, 4, 8]  
		  relations:
		'''
		//empty is an empty model
		val model = parseHelper.parse(program)
		Assert.assertNotNull(model)
		printErrors(model)
		Assert.assertTrue(model.eResource.errors.isEmpty)
	}
	
	
	@Test
	def void common() {
		// An empty hlvl program
		val hlvlProgram = 
		'''
		model commonM
		elements:
		 boolean A
		 boolean B
		relations:
		 r1: common(A,B)
		'''
		//This verifies that the models is syntactically correct
		val model = parseHelper.parse(hlvlProgram)
		Assert.assertNotNull(model)
		printErrors(model)		
		Assert.assertTrue(model.eResource.errors.isEmpty)
	}
	
	@Test
	def void mutex() {
		// An empty hlvl program
		val hlvlProgram = 
		'''
		model mutexM
		elements:
			boolean creditCard
			boolean giftCard
			boolean insecureConnection
			symbolic customerType variants: ['sporadic' , 'regular'] comment: {"What is the customer type?"}
		relations:
			m1: mutex(creditCard, insecureConnection)
			m2: mutex((customerType='sporadic'),[giftCard,creditCard]) 
		'''
		//This verifies that the models is syntactically correct
		val model = parseHelper.parse(hlvlProgram)
		Assert.assertNotNull(model)
		printErrors(model)		
		Assert.assertTrue(model.eResource.errors.isEmpty)
	}
	
	@Test
	def void implies() {
		// An empty hlvl program
		val hlvlProgram = 
		'''
		model implication
		elements:
			boolean payPal
			boolean secureConnection
			boolean customerProfile
			symbolic customerType variants: ['sporadic' , 'regular'] 
								 comment: {"What is the customer type?"}
		relations:
			imp1: implies(payPal, secureConnection)
			imp2: implies((customerType='regular'), [secureConnection,customerProfile])
		'''
		//This verifies that the models is syntactically correct
		val model = parseHelper.parse(hlvlProgram)
		Assert.assertNotNull(model)
		printErrors(model)		
		Assert.assertTrue(model.eResource.errors.isEmpty)
	}
	
	@Test
	def void decomposition() {
		// An empty hlvl program
		val hlvlProgram = 
		'''
		model testDecomposition
		elements:
			boolean card
			boolean creditCard
			boolean giftCard
			boolean debitCard
			boolean payPal
			att integer confidentiality variants: 1..5
			att integer confidentialityBounded is 2
			att integer certificateType variants: 1..5
		relations:
			dc1: decomposition(card, [giftCard, debitCard], [0,1])
			dc2: decomposition(card, [creditCard], [1,1])
			att1:decomposition(payPal,[confidentiality,certificateType], [1,1])
			att2:decomposition(card,[confidentiality,certificateType], [1,1])
		'''
		//This verifies that the models is syntactically correct
		val model = parseHelper.parse(hlvlProgram)
		Assert.assertNotNull(model)
		printErrors(model)		
		Assert.assertTrue(model.eResource.errors.isEmpty)
	}
	
	@Test
	def void group() {
		// An empty hlvl program
		val hlvlProgram = 
		'''
		model testGroup
		elements:
		  	boolean payment
			boolean payPal
			boolean card
		relations:
		  g1: group(payment, [payPal, card], [1,*])
		'''
		//This verifies that the models is syntactically correct
		val model = parseHelper.parse(hlvlProgram)
		Assert.assertNotNull(model)
		printErrors(model)		
		Assert.assertTrue(model.eResource.errors.isEmpty)
	}
	
	@Test
	def void visibility() {
		// An empty hlvl program
		val hlvlProgram = 
		'''
		model testVisibility
		elements:
		  	boolean payment
			boolean payPal
			boolean card
		relations:
		  v1: visibility(productType = 'services', [VR1, VR2])
		'''
		//This verifies that the models is syntactically correct
		val model = parseHelper.parse(hlvlProgram)
		Assert.assertNotNull(model)
		printErrors(model)		
		Assert.assertTrue(model.eResource.errors.isEmpty)
	}
	@Test
	def void expressions() {
		// An empty hlvl program
		val hlvlProgram = 
		'''
		model testExpressions
		elements:
			att integer confidentiality variants: 1..5
			att integer confidentialityBounded is 2
			att integer certificateType variants: 1..5
		relations:
			exp1: expression(3 <= card.confidentiality AND 
				                               card.confidentiality <= 5)
		'''
		//This verifies that the models is syntactically correct
		val model = parseHelper.parse(hlvlProgram)
		Assert.assertNotNull(model)
		printErrors(model)		
		Assert.assertTrue(model.eResource.errors.isEmpty)
	}
/**********************************************************************************************************
* Auxiliar methods for testing
*/

	/**to print the parsing errors */
	def void printErrors(Model model){
		if (!model.eResource.errors.isEmpty){
			for (element : model.eResource.errors) {
				println( element.message)
			}
		}
		
	}
}
