/*
 * generated by Xtext 2.12.0
 */
package com.coffee.generator;

import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.URIConverter;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.resource.XtextResourceSet;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.validation.CheckMode;
import org.eclipse.xtext.validation.IResourceValidator;
import org.eclipse.xtext.validation.Issue;

import com.coffee.HlvlStandaloneSetup;
import com.coffee.generator.boolParser.BasicBoolParser;
import com.coffee.hlvl.Model;
import com.google.inject.Injector;

public class HLVLParser {

	private static HLVLParser instance = null;

	private Injector injector;
	private static ResourceSet resourceSet;
	private static IResourceValidator validator;

	// resource.load(stream, Collections.EMPTY_MAP);

	private HLVLParser() {
		injector = new HlvlStandaloneSetup().createInjectorAndDoEMFRegistration();
		resourceSet = injector.getInstance(XtextResourceSet.class);
		resourceSet.getLoadOptions().put(XtextResource.OPTION_RESOLVE_ALL, Boolean.TRUE);
		validator = injector.getInstance(IResourceValidator.class);
	}

	public static HLVLParser getInstance() {
		if (instance == null)
			instance = new HLVLParser();

		return instance;
	}

	public static String runGenerator(String modelContent) throws IOException {

		Injector injector = new HlvlStandaloneSetup().createInjectorAndDoEMFRegistration();

		final ResourceSet resourceSet = injector.getInstance(XtextResourceSet.class);
		resourceSet.getLoadOptions().put(XtextResource.OPTION_RESOLVE_ALL, Boolean.TRUE);

		final IResourceValidator validator = injector.getInstance(IResourceValidator.class);
		final Resource resource = resourceSet.createResource(URI.createURI("fake.hlvl"));
		final URIConverter.ReadableInputStream stream = new URIConverter.ReadableInputStream(
				new StringReader(modelContent), "UTF-8");
		resource.load(stream, Collections.EMPTY_MAP);

		// Validate the resource
		List<Issue> list = validator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl);
		if (!list.isEmpty()) {
			return list.stream().map(Issue::toString).collect(Collectors.joining("\n"));
		}

		Model model = ((Model) resource.getContents().get(0));
		String modelName = model.getName();
		IHLVLParser parser = ParserFactory.getParser(Dialect.BASIC_BOOL, modelName);
		String result = parser.parseModel(model).toString();

		return result;
	}

	public static Model generateModel(String modelContent) throws Exception {

		Resource resource = resourceSet.createResource(URI.createURI(
				modelContent.substring(modelContent.indexOf(" "), modelContent.indexOf("\n")).trim() + ".hlvl"));
		URIConverter.ReadableInputStream stream = new URIConverter.ReadableInputStream(new StringReader(modelContent),
				"UTF-8");
		resource.load(stream, Collections.EMPTY_MAP);

		// Validate the resource
		List<Issue> list = validator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl);
		if (!list.isEmpty()) {
			throw new Exception(list.stream().map(Issue::toString).collect(Collectors.joining("\n")));
		}

		Model model = ((Model) resource.getContents().get(0));

		return model;
	}

	public static void main(String[] args) throws IOException {
		if (args.length == 0) {

			System.err.println("Aborting: no path to EMF resource provided!");
			return;
		}

		HLVLParser.runGenerator(args[0]);		
	}

	/**
	 * Generates String DIMACS format for a set of models and read them to a data
	 * structure of Lists. The structure consist of three nested lists: The outside
	 * list represents each of the DIMACS formats for the given models. The middle
	 * list represents the set of clauses from a DIMACS format for a specific model.
	 * The inner list represents the set of variables from a clause for a specific
	 * DIMACS format
	 * 
	 * @param models
	 * @return
	 */
	public static List<List<List<Integer>>> getDIMACSs(Model[] models) {

		BasicBoolParser parser = (BasicBoolParser) ParserFactory.getParser(Dialect.BASIC_BOOL, null);

		List<List<List<Integer>>> dimacs = new ArrayList<>();

		for (Model model : models) {
			parser.parseModel(model);
			String currentDimacs = parser.getCNF();

			List<List<Integer>> currentClauses = new ArrayList<>();
			Arrays.asList(currentDimacs.split("\r\n")).forEach(line -> {

				List<Integer> clause = new ArrayList<>();
				if (!(line.startsWith("c") || line.startsWith("p"))) {

					Arrays.asList(line.split(" ")).forEach(variable -> {
						clause.add(new Integer(variable));
					});
					currentClauses.add(clause);

				}
			});

			dimacs.add(currentClauses);
		}
		return dimacs;
	}

	public static List<Integer> getElementsFromDIMACS(List<List<Integer>> dimacs) {

		List<Integer> elements = new ArrayList<>();
		dimacs.forEach(clause -> {
			elements.addAll(clause);
		});
		return elements.stream().map(variable -> Math.abs(variable)).distinct().collect(Collectors.toList());
	}
	
	/**
	 * Creates model objects from an array of HLVL variability models represented as
	 * strings.
	 * 
	 * @param modelsUris: array of HLVL variability models represented as strings.
	 * 
	 * @return Returns an array of model objects that represents the string models
	 *         given as input.
	 * @throws Exception if the content of the any of the models has syntactic
	 *                   errors.
	 */
	public static Model[] generateModels(String[] modelsUris) throws Exception {

		Model[] models = new Model[modelsUris.length];
		for (int i = 0; i < modelsUris.length; i++) {
			models[i] = generateModel(modelsUris[i]);
		}
		return models;
	}
}